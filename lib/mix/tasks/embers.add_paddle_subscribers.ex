defmodule Mix.Tasks.Embers.AddPaddleSubscribers do
  use Igniter.Mix.Task

  @example "mix embers.task.add_paddle_subscribers --example arg"

  @shortdoc "A short description of your task"
  @moduledoc """
  #{@shortdoc}

  Longer explanation of your task

  ## Example

  ```bash
  #{@example}
  ```

  ## Options

  * `--example-option` or `-e` - Docs for your option
  """

  alias Sourceror.Zipper, as: Z

  @impl Igniter.Mix.Task
  def info(_argv, _composing_task) do
    %Igniter.Mix.Task.Info{
      # Groups allow for overlapping arguments for tasks by the same author
      # See the generators guide for more.
      group: :embers,
      # dependencies to add
      adds_deps: [],
      # dependencies to add and call their associated installers, if they exist
      installs: [],
      # An example invocation
      example: @example,
      # a list of positional arguments, i.e `[:file]`
      positional: [],
      # Other tasks your task composes using `Igniter.compose_task`, passing in the CLI argv
      # This ensures your option schema includes options from nested tasks
      composes: [],
      # `OptionParser` schema
      schema: [],
      # Default values for the options in the `schema`
      defaults: [],
      # CLI aliases
      aliases: [],
      # A list of options in the schema that are required
      required: []
    }
  end

  @impl Igniter.Mix.Task
  def igniter(igniter) do
    igniter
    |> add_deps()
    |> update_config()
    |> add_migrations()
    |> add_modules()
    |> add_paddle_script()
    |> add_hook()
    |> add_webhook()
  end

  defp update_config(igniter) do
    igniter
    |> Igniter.Project.Config.configure(
      "dev.exs",
      :embers,
      [Paddle, :environment],
      :sandbox
    )
    |> Igniter.Project.Config.configure(
      "dev.exs",
      :embers,
      [Paddle, :endpoint],
      "https://sandbox-api.paddle.com"
    )
    |> Igniter.Project.Config.configure(
      "prod.exs",
      :embers,
      [Paddle, :environment],
      :production
    )
    |> Igniter.Project.Config.configure(
      "prod.exs",
      :embers,
      [Paddle, :endpoint],
      "https://api.paddle.com"
    )
    |> Igniter.Project.Config.configure(
      "runtime.exs",
      :embers,
      [Paddle, :api_key],
      {:code,
       Sourceror.parse_string!("""
       System.get_env("PADDLE_API_KEY")
       """)}
    )
    |> Igniter.Project.Config.configure(
      "runtime.exs",
      :embers,
      [Paddle, :client_token],
      {:code,
       Sourceror.parse_string!("""
       System.get_env("PADDLE_CLIENT_TOKEN")
       """)}
    )
    |> Igniter.Project.Config.configure(
      "runtime.exs",
      :embers,
      [Paddle, :webhook_signing_key],
      {:code,
       Sourceror.parse_string!("""
       System.get_env("PADDLE_WEBHOOK_SIGNING_KEY")
       """)}
    )
  end

  defp add_migrations(igniter) do
    migration_body = """
    # Generated by Embers task add_paddle_subscribers

    def up do
      Embers.Paddle.Migrations.up()
    end

    def down do
      Embers.Paddle.Migrations.down(version: 1)
    end
    """

    {igniter, repo} = Igniter.Libs.Ecto.select_repo(igniter)

    Igniter.Libs.Ecto.gen_migration(igniter, repo, "add_paddle_customers_and_subscriptions",
      body: migration_body,
      on_exists: {:error, "Migration add_paddle_customers_and_subscriptions already exists"}
    )
  end

  defp add_modules(igniter) do
    app = Igniter.Project.Application.app_name(igniter)
    module_prefix = Igniter.Project.Module.module_name_prefix(igniter)
    web_module = Igniter.Libs.Phoenix.web_module(igniter)
    user_module = Igniter.Project.Module.module_name(igniter, Accounts.User)
    customer_module = Igniter.Project.Module.module_name(igniter, Paddle.Customer)
    customers_module = Igniter.Project.Module.module_name(igniter, Customers)
    subscription_module = Igniter.Project.Module.module_name(igniter, Paddle.Subscription)
    subscriptions_module = Igniter.Project.Module.module_name(igniter, Subscriptions)

    customer_contents =
      Application.app_dir(:embers)
      |> Path.join("priv/templates/paddle/customer_schema.eex")
      |> EEx.eval_file(
        assigns: [subscription_module: subscription_module, user_module: user_module]
      )

    customers_contents =
      Application.app_dir(:embers)
      |> Path.join("priv/templates/customers.eex")
      |> EEx.eval_file(assigns: [module_prefix: module_prefix])

    subscription_contents =
      Application.app_dir(:embers)
      |> Path.join("priv/templates/paddle/subscription_schema.eex")
      |> EEx.eval_file(assigns: [customer_module: customer_module])

    subscriptions_contents =
      Application.app_dir(:embers)
      |> Path.join("priv/templates/subscriptions.eex")
      |> EEx.eval_file(assigns: [app: app, module_prefix: module_prefix])

    pricing_live_contents =
      Application.app_dir(:embers)
      |> Path.join("priv/templates/pricing_live.eex")
      |> EEx.eval_file(assigns: [web_module: web_module, module_prefix: module_prefix])

    subscribe_live_contents =
      Application.app_dir(:embers)
      |> Path.join("priv/templates/subscribe_live.eex")
      |> EEx.eval_file(assigns: [web_module: web_module, module_prefix: module_prefix])

    igniter
    |> Igniter.Project.Module.create_module(customer_module, customer_contents)
    |> Igniter.Project.Module.create_module(customers_module, customers_contents)
    |> Igniter.Project.Module.create_module(subscription_module, subscription_contents)
    |> Igniter.Project.Module.create_module(subscriptions_module, subscriptions_contents)
    |> Igniter.Project.Module.create_module(
      :"#{web_module}.PricingLive",
      pricing_live_contents,
      path: Path.join([web_path(igniter), "live", "pricing_live.ex"])
    )
    |> Igniter.Project.Module.create_module(
      :"#{web_module}.SubscribeLive",
      subscribe_live_contents,
      path: Path.join([web_path(igniter), "live", "subscribe_live.ex"])
    )
    |> Igniter.Libs.Phoenix.append_to_scope(
      "/",
      """
      live_session :pricing,
        on_mount: [{#{inspect(web_module)}.UserAuth, :mount_current_user}] do
        live "/pricing", PricingLive, :index
      end
      """,
      arg2: web_module,
      with_pipelines: [:browser]
    )
    |> Igniter.Libs.Phoenix.append_to_scope(
      "/subscribe",
      """
      live_session :subscribe,
        on_mount: [{#{inspect(web_module)}.UserAuth, :mount_current_user}] do
        live "/:price_id", SubscribeLive, :subscribe
      end
      """,
      arg2: web_module,
      with_pipelines: [:browser, :require_authenticated_user]
    )
  end

  defp add_paddle_script(igniter) do
    path = Path.join([web_path(igniter), "components", "layouts", "root.html.heex"])

    igniter =
      Igniter.update_file(igniter, path, fn source ->
        Rewrite.Source.update(source, :content, fn content ->
          %{updated_content: content} =
            content
            |> String.split("\n")
            |> Enum.reduce(%{added_script: false, updated_content: ""}, fn line, acc ->
              trimmed_line = String.trim(line)
              content = acc.updated_content

              if trimmed_line == "</head>" do
                %{
                  added_script: true,
                  updated_content:
                    content <>
                      """
                          <script :if={assigns[:load_paddle]} src="https://cdn.paddle.com/paddle/v2/paddle.js"></script>
                        </head>
                      """
                }
              else
                %{acc | updated_content: content <> "#{line}\n"}
              end
            end)

          content
        end)
      end)

    if !Igniter.changed?(igniter, path) do
      Igniter.add_warning(
        igniter,
        "Failed to add paddle script to root.html.heex. See https://developer.paddle.com/paddlejs/include-paddlejs"
      )
    else
      igniter
    end
  end

  defp add_hook(igniter) do
    igniter
    |> Igniter.create_new_file("assets/js/hooks/paddle_checkout.js", """
    export default PaddleCheckout = {
      mounted() {
        const token = this.el.dataset.client_token;
        const env = this.el.dataset.environment;

        Paddle.Initialize({
          token: token, eventCallback: (data) => {
            if (data.name == "checkout.closed") {
              window.location.href = "/pricing"
            }
          }
        })

        Paddle.Environment.set(env)

        this.handleEvent("checkout", this.checkout.bind(this));
      },

      async checkout(event) {
        const { items, customer, success_url } = event;

        Paddle.Checkout.open({
          items: items,
          customer: customer,
          settings: {
            successUrl: success_url,
            displayMode: "overlay",
            variant: "one-page"
          }
        })
      }
    }
    """)
    # TODO: Find a way to properly add the hook to the user's app.js
    |> Igniter.add_notice("""
    Make sure you add the paddle_checkout hook to your app.js

      # app.js
      import PaddleCheckout from "./hooks/paddle_checkout";
      ...
      let liveSocket = new LiveSocket("/live", Socket, {
        longPollFallbackMs: 2500,
        params: {_csrf_token: csrfToken},
        hooks: {PaddleCheckout}
      })

    """)
  end

  defp add_deps(igniter) do
    igniter
    |> add_dep(:oban, "~> 2.17")
    |> add_dep(:money, "~> 1.12")
  end

  defp add_dep(igniter, name, version) do
    if Igniter.Project.Deps.has_dep?(igniter, name) do
      igniter
    else
      Igniter.Project.Deps.add_dep(igniter, {name, version}, append?: true)
    end
  end

  def add_webhook(igniter) do
    app = Igniter.Project.Application.app_name(igniter)
    web_module = Igniter.Libs.Phoenix.web_module(igniter)
    module_prefix = Igniter.Project.Module.module_name_prefix(igniter)
    endpoint_path = Path.join([web_path(igniter), "endpoint.ex"])

    caching_body_reader_content =
      Application.app_dir(:embers)
      |> Path.join("priv/templates/caching_body_reader.eex")
      |> EEx.eval_file(assigns: [app: app])

    webhook_content =
      Application.app_dir(:embers)
      |> Path.join("priv/templates/paddle_subscribers/webhooks/paddle_webhook_controller.eex")
      |> EEx.eval_file(assigns: [module_prefix: module_prefix, web_module: web_module])

    worker_content =
      Application.app_dir(:embers)
      |> Path.join("priv/templates/paddle_subscribers/workers/paddle_webhook_worker.eex")
      |> EEx.eval_file(assigns: [module_prefix: module_prefix])

    webhook_controller_path =
      Path.join([web_path(igniter), "controllers", "webhooks", "paddle_webhook_controller.ex"])

    igniter =
      igniter
      |> create_module_if_not_exists(
        :"#{web_module}.Plugs.CachingBodyReader",
        caching_body_reader_content
      )
      |> Igniter.Project.IgniterConfig.dont_move_file_pattern(webhook_controller_path)
      |> Igniter.Project.Module.create_module(
        :"#{web_module}.Webhooks.PaddleWebhookController",
        webhook_content,
        path: webhook_controller_path
      )
      |> Igniter.Project.Module.create_module(
        Igniter.Project.Module.module_name(igniter, Workers.PaddleWebhookWorker),
        worker_content
      )
      |> Igniter.Libs.Phoenix.append_to_scope(
        "/webhooks",
        """
        post "/paddle", PaddleWebhookController, :handle_hook
        """,
        arg2: "#{inspect(web_module)}.Webhooks",
        with_pipelines: [:api]
      )
      |> Igniter.update_elixir_file(endpoint_path, fn zipper ->
        zipper
        |> Z.search_pattern("plug Plug.Parsers, __cursor__()")
        |> Z.within(fn zip ->
          Z.search_pattern(zip, ":body_reader")
          |> case do
            nil ->
              new_node =
                """
                [body_reader: {#{inspect(web_module)}.Plugs.CachingBodyReader, :read_body, []}]
                """
                |> Sourceror.parse_string!()
                |> Z.zip()
                |> Z.next()
                |> Z.next()
                |> Z.node()

              zip
              |> Z.next()
              |> Z.rightmost()
              |> Z.insert_right(new_node)

            _ ->
              zip
          end
        end)
      end)

    if Igniter.changed?(igniter, endpoint_path) do
      igniter
    else
      Igniter.add_warning(igniter, """
      Unable to add CachingBodyReader to #{endpoint_path}.

      The Paddle webhook controller expects the raw request body to be available on the Plug. This is achieved using the CachingBodyReader. Please add the following to your Plug.Parsers definition in #{endpoint_path}.

        body_reader: {#{inspect(web_module)}.Plugs.CachingBodyReader, :ready_body, []}
      """)
    end
  end

  defp create_module_if_not_exists(igniter, module, content, opts \\ []) do
    {exists?, igniter} = Igniter.Project.Module.module_exists(igniter, module)

    if exists? do
      igniter
      |> Igniter.add_warning("Did not create module #{module}. Module already exists.")
    else
      Igniter.Project.Module.create_module(igniter, module, content, opts)
    end
  end

  defp web_path(igniter) do
    web_dir =
      Igniter.Libs.Phoenix.web_module(igniter)
      |> Module.split()
      |> Enum.map(&to_string/1)
      |> Enum.map(&Macro.underscore/1)
      |> Path.join()

    Path.join("lib", web_dir)
  end
end
